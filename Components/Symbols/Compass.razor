@using TestBlazor.Services
@inject CompassService CompassService
@implements IDisposable

<div class="compass-container">
    <svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <!-- Background Circle -->
        <circle cx="50" cy="50" r="45" stroke="black" stroke-width="2" fill="white" />
        
        <!-- Cardinal Directions -->
        <text x="50" y="15" font-family="Arial" font-size="10" text-anchor="middle">N</text>
        <text x="85" y="53" font-family="Arial" font-size="10" text-anchor="middle">E</text>
        <text x="50" y="92" font-family="Arial" font-size="10" text-anchor="middle">S</text>
        <text x="15" y="53" font-family="Arial" font-size="10" text-anchor="middle">W</text>

        <!-- Rotating Arrow -->
        <g transform="rotate(@Heading, 50, 50)">
            <path d="M50 20 L60 80 L50 70 L40 80 Z" fill="red" stroke="black" stroke-width="1" />
        </g>
    </svg>
    <div class="compass-text">@Heading°</div>
</div>

<style>
    .compass-container {
        width: 100%;
        height: 100%;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .compass-text {
        position: absolute;
        bottom: -20px;
        font-weight: bold;
    }
</style>

@code {
    private int Heading => CompassService.Heading;

    protected override void OnInitialized()
    {
        // S'abonne à l'événement de changement du service.
        // Cela permet au composant de réagir aux mises à jour globales.
        CompassService.OnChange += OnCompassChange;
    }

    public void Dispose()
    {
        // Désabonnement crucial pour éviter les fuites de mémoire.
        // Si on ne se désabonne pas, le service gardera une référence vers ce composant, empêchant le Garbage Collector de le détruire.
        CompassService.OnChange -= OnCompassChange;
    }

    private async void OnCompassChange()
    {
        // InvokeAsync assure que StateHasChanged est appelé sur le thread UI correct (le Dispatcher).
        // C'est nécessaire car l'événement peut venir d'un autre contexte (ex: un autre utilisateur/session via un Singleton).
        await InvokeAsync(StateHasChanged);
    }
}
